---
title: "CSN 04 - Community Detection Algorithms"
author: "Carolina Jorge, Laura Cebollero"
date: "14th of November, 2018"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
source("task_01.R")
options(scipen=999)
```
```{r setup2, include=FALSE, echo=FALSE, cache=TRUE}
walktrapCommsWiki = computeWalktrap(wikiG)
```
## Introduction

In this lab we are asked to run and compare different community finding algorithms. In _igraph_ package it is possible to find already some of these algorithms implemented, so we will make use of them. Once we have the communities, we are asked to compute metrics on the communities and, consequently, on the graph. These metrics are *Triangle Partition Ratio (TPT)*, *expansion*, *conductance* and *modularity*. Once computed for each community, we use an weighted average to calculate the global values for the whole network.

# 1. Finding Communities

As proposed, we have used a total of 8 _igraph_'s  algorithms to find communities in our data.

Before applying the different community algorithms, we have taken a brief look at each of their inner workings\footnote{
http://www.cs.upc.edu/~CSN/slides/06communities.pdf} \footnote { https://stackoverflow.com/questions/9471906/what-are-the-differences-between-community-detection-algorithms-in-igraph}
\footnote{ https://www.r-bloggers.com/summary-of-community-detection-algorithms-in-igraph-0-6/}:

*  In *edge.betweeness.community*, edges are removed in the decreasing order of their edge betweenness scores, recomputing every time an edge is removed the betweenness scores.

*  *fastgreedy.community* tries to optimize a quality function called modularity in a greedy manner. Modularity, as we will see in the next section, is the difference between the number of edges in community C and the expected number of expected edges $E[mc]$ of a random graph with the same degree distribution. In other words, it tried to find zones in the network with greater density of edges.

*  *label.propagation.community* tries to assign k labels the nodes of the network. The method then proceeds iteratively and re-assigns labels to nodes in a way that each node takes the most frequent label of its neighbors in a synchronous manner. 

*  *leading.eigenvector.community* also tries to optimize the modularity funtion through the evaluation of the eigenvector of the modularity matrix.

*  In *multilevel.community* nodes are moved between communities such that each node makes a local decision that maximizes its own contribution to the modularity score.

*  *spinglass.community* simmulates the physical _spin_ property and at let the interactions between the nodes (particles) decide how to define a community.

*  *walktrap.community* works based on random walks. It concludes that some walks are more likely to stay within the same community because there are only a few edges that lead outside a given community. Walktrap runs short random walks and uses the results of these random walks to merge separate communities in a bottom-up manner like fastgreedy.community algorithm.

*  *infomap.community* based on information theoretic principles, it tries to build a grouping which provides the shortest description length for a random walk on the graph, where the description length is measured by the expected number of bits per vertex required to encode the path of a random walk.

Please note that *optimal.community* has been deprecated and we have not been able to use it. Thus, we have discarded this method and not applied it.

# 2. Metrics

We have computed the metrics following these definitions:

*  *Triangle partition ratio*: fraction of nodes in C that belong to a triad.

*  *conductance*: fraction of total edge volume that points outside the cluster. To find the total edge volume that point outside the cluster, we calculate the difference between the total number of _outedges_ of the nodes of the community and the number of edges inside the community.

*  *modularity*: difference between the number of edges in C and the expected number of edges E[mc] of a random graph with the same degree distribution.  In this case, we have used the already implemented modularity function of *igraph*.

* *expansion*: number of edges per node leaving the cluster.

After computing the metrics for each community, we have used a weighted average to calculate the global values for the whole network. This being:

\[ 
metric(G) = \sum_{C \in comm(G)} \frac{n_C}{n}*metric(C)
\]
where $n_C$ is the number of nodes of community C and $n$ is the number of total nodes of the whole network.

Additionally, we will also compute the elapsed time on computing the communities with each different algorithms to detect which ones are faster and which ones slower, thus less eficient time-wise.

Finally, we will also reflect how many communities have been found on each algorithm.


## 2.1. Metrics applied on different graphs

To have a general vision on how these community algorithms work in practice, we are going to use them on 5 different networks:

- *Zachary*, which is a famous social network of 34 members from a Karate group.
- *Tutte*, Tait's Hamiltonian graph conjecture, which staates that  every 3-connected 3-regular planar graph is Hamiltonian. \footnote{As per igraph documentation}
- *Coxeter*, a non-Hamiltonian cubic symmetric graph with 28 vertices and 42 edges. \footnote{As per igraph documentation}
- A *modified Thomassen* network. Thomassen is the smallest hypotracable graph. Hypotraceable means that  it does not have a Hamiltonian path. But if a single vertex is removed, the graph now has a Hamiltonian path. We have modified it by adding to it 2 full graphs: one with 5 vertices and another one with 10.
- A graph made with *3 full-connected graphs*, connected between them by 2 edges.

The summary of each graph can be seen in the table below. We have computed the average vertex degree as well as their density:

```{r  echo=FALSE}
kable(summaryTable,
            caption="\\label{tab:table1}Summary table of each graph",
      col.names = c("Graph", "N", "E", "$\\langle k \\rangle$", "$\\delta$"),
      align=rep('c', 5))
```


## Zachary Network

```{r   echo=FALSE, out.width="150px", out.height="150px", fig.align="center"}
plotGraphBeautifully(karate)
```

```{r  echo=FALSE}
kable(karateMetricsTable,
      caption="\\label{tab:tableZachary} Zachary community metrics",
      col.names = c("Method", "$\\Delta$ time", "# $C$", "TPT", "Expansion", "Conduct", "Modularity"))
```


## Tutte
```{r   echo=FALSE, out.width="150px", out.height="150px", fig.align="center"}
plotGraphBeautifully(tutte)
```

```{r  echo=FALSE}
kable(tutteMetricsTable,
      caption="\\label{tab:tableTutte} Tutte community metrics",
      col.names = c("Method", "$\\Delta$ time", "# $C$", "TPT", "Expansion", "Conduct", "Modularity"))
```


## Coxeter
```{r   echo=FALSE, out.width="150px", out.height="150px", fig.align="center"}
plotGraphBeautifully(coxeter)
```

```{r  echo=FALSE}
kable(coxeterMetricsTable,
      caption="\\label{tab:tableCoxeter} Coxeter community metrics",
      col.names = c("Method", "$\\Delta$ time", "# $C$", "TPT", "Expansion", "Conduct", "Modularity"))
```


## Modified Thomassen
```{r   echo=FALSE, out.width="150px", out.height="150px", fig.align="center"}
plotGraphBeautifully(Thomassen)
```

```{r  echo=FALSE}
kable(modThomassenMetricsTable,
      caption="\\label{tab:tableThomas} Modified Thomassen community metrics",
      col.names = c("Method", "$\\Delta$ time", "# $C$", "TPT", "Expansion", "Conduct", "Modularity"))
```


## Three full connected graphs
```{r   echo=FALSE, out.width="150px", out.height="150px", fig.align="center"}
plotGraphBeautifully(full3Graphs)
```

```{r  echo=FALSE}
kable(full3MetricsTable,
      caption="\\label{tab:table3f} Three full connected graphs community metrics",
      col.names = c("Method", "$\\Delta$ time", "# $C$", "TPT", "Expansion", "Conduct", "Modularity"))
```


## 2.2. Metrics discussion

We can see that in all networks, spinglass has been the slowest algorithm to compute the communities by a large margin.

TPT has resulted in a 0 in the Tutte and Coxeter networks. This is due to the communities found in coxeter and Tutte not having any triads in any algorithm. 

For example, let's look at those communities found with *walktrap* in Coxeter:

```{r   echo=FALSE, out.width="200px", out.height="150px", fig.align="center"}
walktrap = walktrap.community(coxeter)
plot(walktrap, coxeter)
```

We can see that, as we thought, there are triads in the whole network. But once we apply the TPT to the communities found, these triads are, in fact, split by their vertices being from different communities.


Leading has not found any communities in Tutte and Coxeter. So the evaluation of the eigenvector in the modularity matrix for these two networks has not been effective.

In the case of the three full connected graph, the algorithms have found 3 communities each as we expected. There's is one exception, tho, which is the leading algorithm, which has found 4.


# 2. Wikipedia community detection

Now we are going to detect the communities on the Wikipedia dataset provided in `wikipedia.gml`.

```{r  echo=FALSE, cache=TRUE}
kable(computeSummaryTableForWiki(wikiG),
            caption="\\label{tab:tableWiki}Summary table of Wikipedia graph",
      col.names = c("Graph", "N", "E", "$\\langle k \\rangle$", "$\\delta$"),
      align=rep('c', 5))
```

We can see that this network is really large albeit not that dense. It seems that as of the average, each article is connected to 6 other articles.


Due to its size, *edge betweeness* as a community detection algorithm has been immediately discarded
by us for it is high computational demanding due to its inner working methods of computing the betweenesses, removing the edge with the highest betweeness, recomputing the betweenesses, then restoring the edge and removing another one, compute again...[ And so on][ref]. 

Looking at the tables in the Metrics section, we can see that the fastest community detection algorithms are walktrap, multilevel, label, infomap and fastgreedy.

Multilevel cannot be used because it needs the graph to be undirected and we are dealing, in fact, with a directed graph.

We have chosen to perform the community detection with Walktrap because it works based on random walks. It concludes that some walks are more likely to stay within the same community because there are only a few edges that lead outside a given community. Walktrap runs short random walks and uses the results of these random walks to merge separate communities in a bottom-up manner like fastgreedy.community algorithm.

\newpage

Let's take a look at the total number of communities found with a function 
we have implemented:
```{r}
printNumberOfCommunitiesFound(walktrapCommsWiki)
```

The number of communities found is quite large. As is the whole network. 

We have tried to plot the whole graph but of course nothing can really be determined
by looking at it, because it is very crowded as seen in  figure 1.

![Global graph plot](figures/walktrappComms_Plot.png)



Because of this we are only going to take a look at the first 3 communities detected.
```{r   out.width="350px", out.height="350px", fig.align='center'}
x = 3
plotGraphFirstXCommunities(walktrapCommsWiki, wikiG, x)
```



# Summary

Spinglass has proven to be the slowest method.

Leading has found 4 communities instead of 3 in the 3 full connected graphs. And has found only 1 in Tutte and Coxeter. We are sure that this algorithm may prove effective with some specific networks. But it has proven not being that reliable for us in 3 out of 5 test cases.

Future work would include taking a closer look on the leading algorithm implementation and research for which type of networks or goals it is useful to be applied.

TODO: write discussions of problems encountered & things learned

# References

[ref]: https://arxiv.org/pdf/cond-mat/0112110.pdf "referenceees!"